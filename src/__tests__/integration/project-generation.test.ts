import { createApp } from '../../commands/create'
import fs from 'fs-extra'
import path from 'path'
import { execSync } from 'child_process'
import { createTempDir, cleanupTempDir } from '../setup'

// Mock external dependencies
jest.mock('child_process')
jest.mock('inquirer')
jest.mock('ora')

const mockExecSync = execSync as jest.MockedFunction<typeof execSync>

import inquirer from 'inquirer'
const mockInquirer = inquirer as jest.Mocked<typeof inquirer>

import ora from 'ora'
const mockOra = ora as jest.Mocked<typeof ora>

// Mock ora spinner
function createMockSpinner() {
  return {
    start: jest.fn().mockReturnThis(),
    succeed: jest.fn().mockReturnThis(),
    fail: jest.fn().mockReturnThis()
  }
}

const mockSpinner = createMockSpinner()
;(mockOra as any).mockReturnValue(mockSpinner)

describe('项目生成集成测试', () => {
  let tempDir: string

  beforeEach(async () => {
    tempDir = await createTempDir()
    jest.clearAllMocks()
    
    // Mock process methods
    jest.spyOn(process, 'cwd').mockReturnValue(tempDir)
    jest.spyOn(process, 'chdir').mockImplementation()
    jest.spyOn(process, 'exit').mockImplementation((code?: string | number | null) => {
      throw new Error(`Process exit with code: ${code}`)
    })
    
    // Mock console methods to avoid noise in test output
    jest.spyOn(console, 'log').mockImplementation()
    jest.spyOn(console, 'error').mockImplementation()
    jest.spyOn(console, 'warn').mockImplementation()
    
    mockExecSync.mockImplementation(() => Buffer.from(''))
  })

  afterEach(async () => {
    await cleanupTempDir(tempDir)
    jest.restoreAllMocks()
  })

  describe('默认模板生成', () => {
    test('应该生成完整的默认项目结构', async () => {
      const projectName = 'default-test-app'

      mockInquirer.prompt.mockResolvedValueOnce({
        overwrite: true,
        template: 'default',
        database: 'postgresql',
        features: ['auth', 'upload'],
        uiFramework: 'tailwind-radix'
      })

      await createApp(projectName, {})

      const projectPath = path.join(tempDir, projectName)

      // 验证核心文件存在
      expect(await fs.pathExists(path.join(projectPath, 'package.json'))).toBe(true)
      expect(await fs.pathExists(path.join(projectPath, 'tsconfig.json'))).toBe(true)
      expect(await fs.pathExists(path.join(projectPath, 'next.config.js'))).toBe(true)
      expect(await fs.pathExists(path.join(projectPath, 'tailwind.config.js'))).toBe(true)
      expect(await fs.pathExists(path.join(projectPath, 'postcss.config.js'))).toBe(true)

      // 验证应用目录结构
      expect(await fs.pathExists(path.join(projectPath, 'src', 'app'))).toBe(true)
      expect(await fs.pathExists(path.join(projectPath, 'src', 'components'))).toBe(true)
      expect(await fs.pathExists(path.join(projectPath, 'src', 'lib'))).toBe(true)

      // 验证Next.js文件
      expect(await fs.pathExists(path.join(projectPath, 'src', 'app', 'layout.tsx'))).toBe(true)
      expect(await fs.pathExists(path.join(projectPath, 'src', 'app', 'page.tsx'))).toBe(true)
      expect(await fs.pathExists(path.join(projectPath, 'src', 'app', 'globals.css'))).toBe(true)

      // 验证数据库文件
      expect(await fs.pathExists(path.join(projectPath, 'prisma', 'schema.prisma'))).toBe(true)
      expect(await fs.pathExists(path.join(projectPath, '.env.example'))).toBe(true)

      // 验证文件内容
      const packageJson = await fs.readJson(path.join(projectPath, 'package.json'))
      expect(packageJson.name).toBe(projectName)
      expect(packageJson.dependencies).toHaveProperty('next')
      expect(packageJson.dependencies).toHaveProperty('@prisma/client')
      expect(packageJson.devDependencies).toHaveProperty('tailwindcss')

      const prismaSchema = await fs.readFile(path.join(projectPath, 'prisma', 'schema.prisma'), 'utf-8')
      expect(prismaSchema).toContain('provider = "postgresql"')
      expect(prismaSchema).toContain('model User')

      const layoutContent = await fs.readFile(path.join(projectPath, 'src', 'app', 'layout.tsx'), 'utf-8')
      expect(layoutContent).toContain('title: \'')
      expect(layoutContent).toContain('Generated by VibeCLI')

      const pageContent = await fs.readFile(path.join(projectPath, 'src', 'app', 'page.tsx'), 'utf-8')
      expect(pageContent).toContain('欢迎使用 VibeCLI')
    })
  })

  describe('不同数据库配置', () => {
    test('应该正确配置MySQL数据库', async () => {
      const projectName = 'mysql-test-app'

      mockInquirer.prompt.mockResolvedValueOnce({
        overwrite: true,
        template: 'default',
        database: 'mysql',
        features: [],
        uiFramework: 'tailwind-radix'
      })

      await createApp(projectName, { database: 'mysql' })

      const projectPath = path.join(tempDir, projectName)
      const prismaSchema = await fs.readFile(path.join(projectPath, 'prisma', 'schema.prisma'), 'utf-8')
      
      expect(prismaSchema).toContain('provider = "mysql"')

      const envExample = await fs.readFile(path.join(projectPath, '.env.example'), 'utf-8')
      expect(envExample).toContain('mysql://username:password@localhost:5432/database')
    })

    test('应该正确配置SQLite数据库', async () => {
      const projectName = 'sqlite-test-app'

      mockInquirer.prompt.mockResolvedValueOnce({
        overwrite: true,
        template: 'default',
        database: 'sqlite',
        features: [],
        uiFramework: 'tailwind-radix'
      })

      await createApp(projectName, { database: 'sqlite' })

      const projectPath = path.join(tempDir, projectName)
      const prismaSchema = await fs.readFile(path.join(projectPath, 'prisma', 'schema.prisma'), 'utf-8')
      
      expect(prismaSchema).toContain('provider = "sqlite"')
      
      // SQLite不应该运行prisma generate
      expect(mockExecSync).not.toHaveBeenCalledWith('npx prisma generate', { stdio: 'pipe' })
    })
  })

  describe('UI框架配置', () => {
    test('应该正确配置Tailwind CSS + Radix UI', async () => {
      const projectName = 'tailwind-test-app'

      mockInquirer.prompt.mockResolvedValueOnce({
        overwrite: true,
        template: 'default',
        database: 'sqlite',
        features: [],
        uiFramework: 'tailwind-radix'
      })

      await createApp(projectName, {})

      const projectPath = path.join(tempDir, projectName)
      
      // 验证Tailwind配置文件
      expect(await fs.pathExists(path.join(projectPath, 'tailwind.config.js'))).toBe(true)
      expect(await fs.pathExists(path.join(projectPath, 'postcss.config.js'))).toBe(true)

      // 验证package.json中的依赖
      const packageJson = await fs.readJson(path.join(projectPath, 'package.json'))
      expect(packageJson.devDependencies).toHaveProperty('tailwindcss')
      expect(packageJson.devDependencies).toHaveProperty('autoprefixer')
      expect(packageJson.devDependencies).toHaveProperty('postcss')
      expect(packageJson.dependencies).toHaveProperty('@radix-ui/react-slot')
      expect(packageJson.dependencies).toHaveProperty('class-variance-authority')
      expect(packageJson.dependencies).toHaveProperty('clsx')
      expect(packageJson.dependencies).toHaveProperty('tailwind-merge')

      // 验证全局CSS
      const globalsCss = await fs.readFile(path.join(projectPath, 'src', 'app', 'globals.css'), 'utf-8')
      expect(globalsCss).toContain('@tailwind base')
      expect(globalsCss).toContain('@tailwind components')
      expect(globalsCss).toContain('@tailwind utilities')

      // 验证Tailwind配置内容
      const tailwindConfig = await fs.readFile(path.join(projectPath, 'tailwind.config.js'), 'utf-8')
      expect(tailwindConfig).toContain('./src/pages/**/*.{js,ts,jsx,tsx,mdx}')
      expect(tailwindConfig).toContain('./src/components/**/*.{js,ts,jsx,tsx,mdx}')
      expect(tailwindConfig).toContain('./src/app/**/*.{js,ts,jsx,tsx,mdx}')
    })
  })

  describe('功能模块配置', () => {
    test('应该处理多个功能选择', async () => {
      const projectName = 'features-test-app'

      mockInquirer.prompt.mockResolvedValueOnce({
        overwrite: true,
        template: 'default',
        database: 'postgresql',
        features: ['auth', 'admin', 'upload', 'email'],
        uiFramework: 'tailwind-radix'
      })

      await createApp(projectName, {})

      const projectPath = path.join(tempDir, projectName)
      
      // 基本验证项目创建成功
      expect(await fs.pathExists(path.join(projectPath, 'package.json'))).toBe(true)
      expect(await fs.pathExists(path.join(projectPath, 'src', 'app', 'layout.tsx'))).toBe(true)

      // 验证命令执行
      expect(mockExecSync).toHaveBeenCalledWith('npm install', { stdio: 'pipe' })
      expect(mockExecSync).toHaveBeenCalledWith('npx prisma generate', { stdio: 'pipe' })
    })
  })

  describe('TypeScript配置', () => {
    test('应该生成有效的TypeScript配置', async () => {
      const projectName = 'typescript-test-app'

      mockInquirer.prompt.mockResolvedValueOnce({
        overwrite: true,
        template: 'default',
        database: 'sqlite',
        features: [],
        uiFramework: 'tailwind-radix'
      })

      await createApp(projectName, {})

      const projectPath = path.join(tempDir, projectName)
      const tsConfig = await fs.readJson(path.join(projectPath, 'tsconfig.json'))

      expect(tsConfig.compilerOptions).toBeDefined()
      expect(tsConfig.compilerOptions.target).toBe('es5')
      expect(tsConfig.compilerOptions.lib).toContain('dom')
      expect(tsConfig.compilerOptions.strict).toBe(true)
      expect(tsConfig.compilerOptions.jsx).toBe('preserve')
      expect(tsConfig.compilerOptions.paths).toHaveProperty('@/*', ['./src/*'])
      expect(tsConfig.include).toContain('**/*.ts')
      expect(tsConfig.include).toContain('**/*.tsx')
      expect(tsConfig.exclude).toContain('node_modules')
    })
  })

  describe('命令执行顺序', () => {
    test('应该按正确顺序执行安装和初始化命令', async () => {
      const projectName = 'order-test-app'

      mockInquirer.prompt.mockResolvedValueOnce({
        overwrite: true,
        template: 'default',
        database: 'postgresql',
        features: [],
        uiFramework: 'tailwind-radix'
      })

      await createApp(projectName, {})

      // 验证命令执行顺序
      const calls = mockExecSync.mock.calls
      expect(calls).toHaveLength(2)
      expect(calls[0][0]).toBe('npm install')
      expect(calls[1][0]).toBe('npx prisma generate')

      // 验证spinner调用
      expect(mockSpinner.start).toHaveBeenCalledWith('正在创建项目...')
      expect(mockSpinner.succeed).toHaveBeenCalledWith('项目创建成功!')
      expect(mockSpinner.start).toHaveBeenCalledWith('正在安装依赖...')
      expect(mockSpinner.succeed).toHaveBeenCalledWith('依赖安装完成!')
      expect(mockSpinner.start).toHaveBeenCalledWith('正在初始化数据库...')
      expect(mockSpinner.succeed).toHaveBeenCalledWith('数据库初始化完成!')
    })
  })

  describe('错误处理集成', () => {
    test('应该正确处理文件系统错误', async () => {
      const projectName = 'fs-error-test'

      mockInquirer.prompt.mockResolvedValueOnce({
        overwrite: true,
        template: 'default',
        database: 'sqlite',
        features: [],
        uiFramework: 'tailwind-radix'
      })

      // Mock writeFile to throw error
      const mockWriteFile = jest.spyOn(fs, 'writeFile') as any
      mockWriteFile.mockRejectedValue(new Error('Write permission denied'))

      await expect(createApp(projectName, {})).rejects.toThrow('Process exit with code: 1')
      expect(mockSpinner.fail).toHaveBeenCalledWith('项目创建失败')
    })

    test('应该正确处理依赖安装错误', async () => {
      const projectName = 'install-error-test'

      mockInquirer.prompt.mockResolvedValueOnce({
        overwrite: true,
        template: 'default',
        database: 'sqlite',
        features: [],
        uiFramework: 'tailwind-radix'
      })

      mockExecSync.mockImplementation((command) => {
        if (command === 'npm install') {
          throw new Error('Network error')
        }
        return Buffer.from('')
      })

      await expect(createApp(projectName, {})).rejects.toThrow('Process exit with code: 1')
      expect(mockSpinner.fail).toHaveBeenCalledWith('项目创建失败')
    })
  })
})